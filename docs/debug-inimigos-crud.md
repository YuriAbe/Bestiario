# ğŸ“„ **DOCUMENTAÃ‡ÃƒO â€” Linha do Tempo de Erros e SoluÃ§Ãµes do CRUD de Inimigos**

### *Projeto: BestiÃ¡rio (Spring Boot + JPA/Hibernate + Thymeleaf)*

### *Autor: Yuri Abe*
#### *DocumentaÃ§Ã£o e projeto realizado com auxÃ­lio de um agente de IA, principalmente na anÃ¡lise de debugs e resoluÃ§Ã£o de erros.*

### *Data da Ãºltima atualizaÃ§Ã£o: 28/11/2025*

---

# ğŸ§­ **1. Objetivo da DocumentaÃ§Ã£o**

Este documento registra **todos os erros encontrados durante o desenvolvimento do CRUD de Inimigos**, incluindo:

* Erros no Controller, DTO, Service e Views
* Problemas de validaÃ§Ã£o
* ExceÃ§Ãµes do Spring MVC
* Problemas de conversÃ£o Model â†” DTO
* Erros de infraestrutura (banco de dados, PK duplicada)
* SoluÃ§Ãµes aplicadas
* Boas prÃ¡ticas aprendidas

O objetivo Ã© servir como material de consulta futura para **rÃ¡pida resoluÃ§Ã£o de problemas** em outros projetos Spring Boot.

---

# ğŸ“Œ **2. Linha do Tempo dos Erros e SoluÃ§Ãµes**

---

## ğŸŸ¥ **ERRO 1 â€” FormulÃ¡rio de ediÃ§Ã£o nÃ£o funcionava**

### **Sintoma**

Ao editar um inimigo, a aplicaÃ§Ã£o retornava erro 500 ou 404.

### **Causa Raiz**

No mÃ©todo `edit()` do `InimigoController`, o objeto `inimigo` nÃ£o estava sendo enviado corretamente para a view.
O DTO retornado para a view nÃ£o continha o `jogo_id`.

### **SoluÃ§Ã£o Aplicada**

* Ajustar o mÃ©todo `toDTO()` na `InimigoService`
* Garantir que o `jogo_id` seja preenchido corretamente

```java
dto.setJogo_id(
    model.getJogo() != null ? model.getJogo().getId() : null
);
```

### âœ”ï¸ Resultado

O formulÃ¡rio passou a preencher corretamente todos os campos.

---

## ğŸŸ¥ **ERRO 2 â€” CriaÃ§Ã£o (`create`) nÃ£o funcionava / NullPointerException**

### **Sintoma**

Ao salvar um novo inimigo, surgia `NullPointerException`, tratado pelo `GlobalExceptionHandler`.

### **Causa Raiz**

O binding do formulÃ¡rio nÃ£o estava correto. O Controller nÃ£o devolvia o DTO preenchido quando havia erro de validaÃ§Ã£o.

### **SoluÃ§Ã£o Aplicada**

```java
if (result.hasErrors()) {
    model.addAttribute("inimigo", inimigoDTO);
    model.addAttribute("jogos", jogoRepository.findAll());
    return "inimigos/create";
}
```

### âœ”ï¸ Resultado

O formulÃ¡rio passou a ser re-renderizado corretamente apÃ³s erros.

---

## ğŸŸ¥ **ERRO 3 â€” ConversÃ£o DTO â†’ Model incompleta (origem do 500)**

### **Sintoma**

O create continuava falhando mesmo com todos os campos corretos.

### **Causa Raiz**

O mÃ©todo `toModel()` nÃ£o carregava corretamente o objeto `JogoModel`.

### **SoluÃ§Ã£o Aplicada**

Carregar o jogo com validaÃ§Ã£o:

```java
if (dto.getJogo_id() != null) {
    JogoModel jogo = jogoRepository.findById(dto.getJogo_id())
            .orElseThrow(() -> new ResourceNotFoundException("Jogo nÃ£o encontrado"));
    model.setJogo(jogo);
}
```

---

## ğŸŸ¥ **ERRO 4 â€” ExceÃ§Ãµes sendo capturadas como `NoResourceFoundException`**

### **Sintoma**

O console mostrava vÃ¡rias linhas:

```
classe: class org.springframework.web.servlet.resource.NoResourceFoundException
```

Mesmo quando o problema nÃ£o era arquivo estÃ¡tico ausente.

### **Causa Raiz**

O `GlobalExceptionHandler` capturava TUDO como `NoResourceFoundException`.

### **SoluÃ§Ã£o Aplicada**

Criar mÃ©todos especÃ­ficos:

```java
@ExceptionHandler(NoResourceFoundException.class)
public String handleNoResourceFoundException(...) { ... }

@ExceptionHandler(Exception.class)
public String handleAllExceptions(...) { ... }
```

### âœ”ï¸ Resultado

Agora cada erro Ã© tratado corretamente.

---

## ğŸŸ¥ **ERRO 5 â€” PK duplicada ao inserir novo inimigo**

### **Sintoma**

```
ERROR: duplicate key value violates unique constraint "inimigos_pkey"
Key (id)=(3) already exists.
```

### **Causa Raiz**

A coluna `id` estava marcada como:

```
GENERATED BY DEFAULT AS IDENTITY
```

â— *Isso permite inserir IDs manualmente.*
O Hibernate estava enviando ID=3 mesmo no create.

AlÃ©m disso, a *sequence* do Postgres estava desatualizada.

### **SoluÃ§Ã£o Aplicada**

1. Confirmar que o Model usa:

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

2. Resetar a sequence:

```sql
SELECT setval(
    pg_get_serial_sequence('inimigos', 'id'),
    (SELECT MAX(id) FROM inimigos) + 1,
    false
);
```

### âœ”ï¸ Resultado

A criaÃ§Ã£o funcionou perfeitamente.

---

# ğŸ§° **3. Boas PrÃ¡ticas Aprendidas**

### âœ”ï¸ Sempre valide DTO â†’ Model e Model â†’ DTO

Evita 70% dos problemas em CRUDs.

### âœ”ï¸ Sempre retorne DTO preenchido no Controller quando houver erro

Ou o formulÃ¡rio volta sem dados.

### âœ”ï¸ Configure um *Global Exception Handler* limpo e separado

Controllers ficam 100% focados em regras de negÃ³cio.

### âœ”ï¸ Sempre verifique a sequence do Postgres quando houver:

`duplicate key value violates unique constraint`

### âœ”ï¸ Use `@GeneratedValue(strategy = GenerationType.IDENTITY)`

Nunca deixe JPA deduzir o mÃ©todo de geraÃ§Ã£o.

### âœ”ï¸ Sempre confira o HTML:

* `th:field="*{campo}"`
* `th:object="${inimigo}"`

### âœ”ï¸ Ao mexer em chave primÃ¡ria, considere RECRIAR a tabela

(sem perder dados)

---

# ğŸ“¦ **4. Arquivos que foram corrigidos durante o processo**

### âœ”ï¸ `InimigoController`

### âœ”ï¸ `InimigoService`

### âœ”ï¸ `InimigoDTO`

### âœ”ï¸ `InimigoModel`

### âœ”ï¸ `create.html` e `edit.html`

### âœ”ï¸ `GlobalExceptionHandler`

### âœ”ï¸ SequÃªncia `inimigos_id_seq` no Postgres

### âœ”ï¸ Estrutura da tabela `inimigos`

---

# ğŸ”„ **5. PossÃ­veis Melhorias Futuras**

* Implementar validaÃ§Ã£o customizada com Bean Validation
* Implementar logs com SLF4J (em vez de `System.out.println`)
* Criar testes automatizados para DTO â†” Model
* Adicionar paginaÃ§Ã£o e filtros
* Criar camada de conversÃ£o (Mapper) usando MapStruct
* Implementar Flyway/Liquibase para migraÃ§Ãµes seguras

---

# ğŸ“˜ **6. ConclusÃ£o**

Este documento reÃºne todo o aprendizado e soluÃ§Ãµes aplicadas ao resolver problemas reais no CRUD de inimigos.
Ele ajudarÃ¡ a identificar padrÃµes de erro antes que aconteÃ§am novamente, acelerando o desenvolvimento de futuros projetos Spring Boot.